C指针学习(转)  

2005-6-13 
  
第一章。指针的概念  


指针变量是一个特殊的变量，
它里面存储的数值被解释成为内存里的一个地址。  

要搞清一个指针需要搞清指针的四方面的内容：
指针的类型，指针所指向的类型，
指针的值或者叫指针所指向的内存区，
还有指针本身所占据的内存区。

让我们分别说明。  
先声明几个指针放着做例子：  
例一：  
(1)int*ptr;  
(2)char*ptr;  
(3)int**ptr;  
(4)int(*ptr)[3];  
(5)int*(*ptr)[4];  
如果看不懂后几个例子的话，请参阅我前段时间贴出的文章
<<如何理解c和c++的复杂类型声明>>。  

1。指针的类型。  
从语法的角度看，你只要把指针声明语句里的指针名字去掉，
剩下的部分就是这个指针的类型。这是指针本身所具有的类型。
让我们看看例一中各个指针的类型：
  
(1)int*ptr;//指针的类型是int*  
(2)char*ptr;//指针的类型是char*  
(3)int**ptr;//指针的类型是int**  
(4)int(*ptr)[3];//指针的类型是int(*)[3]  
(5)int*(*ptr)[4];//指针的类型是int*(*)[4]  
怎么样？找出指针的类型的方法是不是很简单？  

2。指针所指向的类型。  
当你通过指针来访问指针所指向的内存区时，
指针所指向的类型决定了编译器将把那片内存区里的内容
当做什么来看待。  
从语法上看，
你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：  

(1)int*ptr;//指针所指向的类型是int  
(2)char*ptr;//指针所指向的的类型是char  
(3)int**ptr;//指针所指向的的类型是int*  
(4)int(*ptr)[3];//指针所指向的的类型是int()[3]  
(5)int*(*ptr)[4];//指针所指向的的类型是int*()[4] 
 
在指针的算术运算中，指针所指向的类型有很大的作用。  
指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。
当你对C越来越熟悉时，你会发现，
把与指针搅和在一起的"类型"这个概念分成"针的类型"
和"指针所指向的类型"两个概念，是精通指针的关键点之一。
我看了不少书，发现有些写得差的书中，
就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，
越看越糊涂。  

3。指针的值，或者叫指针所指向的内存区或地址。
  
指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，
而不是一个一般的数值。
在32位程序里，所有类型的指针的值都是一个32位整数，
因为32位程序里内存地址全都是32位长。  
指针所指向的内存区就是从指针的值所代表的那个内存地址开始，
长度为sizeof(指针所指向的类型)的一片内存区。
以后，我们说一个指针的值是XX，
就相当于说该指针指向了以XX为首地址的一片内存区域；
我们说一个指针指向了某块内存区域，
就相当于说该指针的值是这块内存区域的首地址。
  
指针所指向的内存区和指针所指向的类型是两个完全不同的概念。
在例一中，指针所指向的类型已经有了，但由于指针还未初始化，
所以它所指向的内存区是不存在的，或者说是无意义的。  
以后，每遇到一个指针，都应该问问：
这个指针的类型是什么？指针指向的类型是什么？该指针指向了哪里？  
4。指针本身所占据的内存区。  
指针本身占了多大的内存？
你只要用函数sizeof(指针的类型)测一下就知道了。
在32位平台里，指针本身占据了4个字节的长度。  
指针本身占据的内存这个概念
在判断一个指针表达式是否是左值时很有用。 


第二章。指针的算术运算  


指针可以加上或减去一个整数。
指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。
例如：  
例二：  
1。Chara[20];  
2。Int*ptr=a;  
…  
…  
3。Ptr++;  
在上例中，指针ptr的类型是int*,它指向的类型是int，它被初始化为指向整  
形变量a。接下来的第3句中，指针ptr被加了1，编译器是这样处理的：它把指针  
 
 
  
 作者： 61.128.167.*  2006-5-12 14:45 　 回复此发言    
 
--------------------------------------------------------------------------------
 
2 C指针学习(转)  
 ptr的值加上了sizeof(int)，在32位程序中，是被加上了4。由于地址是用字节做  
单位的，故ptr所指向的地址由原来的变量a的地址向高地址方向增加了4个字节。  
由于char类型的长度是一个字节，所以，原来ptr是指向数组a的第0号单元开始的  
四个字节，此时指向了数组a中从第4号单元开始的四个字节。  
我们可以用一个指针和一个循环来遍历一个数组，看例子：  
例三：  
例三：  
intarray[20];  
int*ptr=array;  
…  
//此处略去为整型数组赋值的代码。  
…  
for(i=0;i<20;i++)  
{  
(*ptr)++;  
ptr++；  
}  
这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1，所  
以每次循环都能访问数组的下一个单元。  
再看例子：  
例四：  
1。Chara[20];  
2。Int*ptr=a;  
…  
…  
3。Ptr+=5;  
在这个例子中，ptr被加上了5，编译器是这样处理的：将指针ptr的值加上5  
乘sizeof(int)，在32位程序中就是加上了5乘4=20。由于地址的单位是字节，故  
现在的ptr所指向的地址比起加5后的ptr所指向的地址来说，向高地址方向移动了  
20个字节。在这个例子中，没加5前的ptr指向数组a的第0号单元开始的四个字节  
，加5后，ptr已经指向了数组a的合法范围之外了。虽然这种情况在应用上会出问  
题，但在语法上却是可以的。这也体现出了指针的灵活性。  
如果上例中，ptr是被减去5，那么处理过程大同小异，只不过ptr的值是被减  
去5乘sizeof(int)，新的ptr指向的地址将比原来的ptr所指向的地址向低地址方  
向移动了20个字节。  

总结一下，一个指针ptrold加上一个整数n后，结果是一个新的指针ptrnew，  
ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型  
也相同。Ptrnew的值将比ptrold的值增加了n乘sizeof(ptrold所指向的类型)个字  
节。就是说，ptrnew所指向的内存区将比ptrold所指向的内存区向高地址方向移  
动了n乘sizeof(ptrold所指向的类型)个字节。  
一个指针ptrold减去一个整数n后，结果是一个新的指针ptrnew，ptrnew的类  
型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。Pt  
rnew的值将比ptrold的值减少了n乘sizeof(ptrold所指向的类型)个字节，就是说  
，ptrnew所指向的内存区将比ptrold所指向的内存区向低地址方向移动了n乘siz  
eof(ptrold所指向的类型)个字节。  


第三章。运算符&和*  


这里&是取地址运算符，*是…书上叫做"间接运算符"。  
&a的运算结果是一个指针，指针的类型是a的类型加个*，指针所指向的类型  
是a的类型，指针所指向的地址嘛，那就是a的地址。  
*p的运算结果就五花八门了。总之*p的结果是p所指向的东西，这个东西有这  
些特点：它的类型是p指向的类型，它所占用的地址是p所指向的地址。  
例五：  
inta=12;  
intb;  
int*p;  
int**ptr;  
p=&a;//&a的结果是一个指针，类型是int*，指向的类型是int，指向的地址  
是a的地址。  
*p=24;//*p的结果，在这里它的类型是int，它所占用的地址是p所指向的地  
址，显然，*p就是变量a。  
ptr=&p;//&p的结果是个指针，该指针的类型是p的类型加个*，在这里是int  
**。该指针所指向的类型是p的类型，这里是int*。该指针所指向的地址就是指针  
p自己的地址。  
*ptr=&b;//*ptr是个指针，&b的结果也是个指针，且这两个指针的类型和所  
指向的类型是一样的，所以用&b来给*ptr赋值就是毫无问题的了。  
**ptr=34;//*ptr的结果是ptr所指向的东西，在这里是一个指针，对这个指  
针再做一次*运算，结果就是一个int类型的变量。  

第四章。指针表达式。  


一个表达式的最后结果如果是一个指针，那么这个表达式就叫指针表达式。  
下面是一些指针表达式的例子：  
例六：  
inta,b;  
intarray[10];  
int*pa;  
pa=&a;//&a是一个指针表达式。  
 
 
  
 作者： 61.128.167.*  2006-5-12 14:45 　 回复此发言    
 
--------------------------------------------------------------------------------
 
3 C指针学习(转)  
 int**ptr=&pa;//&pa也是一个指针表达式。  
*ptr=&b;//*ptr和&b都是指针表达式。  
pa=array;  
pa++;//这也是指针表达式。  
例七：  
char*arr[20];  
char**parr=arr;//如果把arr看作指针的话，arr也是指针表达式  
char*str;  
str=*parr;//*parr是指针表达式  
str=*(parr+1);//*(parr+1)是指针表达式  
str=*(parr+2);//*(parr+2)是指针表达式  


由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四  
个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的  
内存。  
好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存  
的话，这个指针表达式就是一个左值，否则就不是一个左值。  
在例七中，&a不是一个左值，因为它还没有占据明确的内存。*ptr是一个左  
值，因为*ptr这个指针已经占据了内存，其实*ptr就是指针pa，既然pa已经在内  
存中有了自己的位置，那么*ptr当然也有了自己的位置。  

第五章。数组和指针的关系  


如果对声明数组的语句不太明白的话，请参阅我前段时间贴出的文章<<如何  
理解c和c++的复杂类型声明>>。  
数组的数组名其实可以看作一个指针。看下例：  
例八：  
intarray[10]={0,1,2,3,4,5,6,7,8,9},value;  
…  
…  
value=array[0];//也可写成：value=*array;  
value=array[3];//也可写成：value=*(array+3);  
value=array[4];//也可写成：value=*(array+4);  
上例中，一般而言数组名array代表数组本身，类型是int[10]，但如果把a  
rray看做指针的话，它指向数组的第0个单元，类型是int*，所指向的类型是数  
组单元的类型即int。因此*array等于0就一点也不奇怪了。同理，array+3是一个  
指向数组第3个单元的指针，所以*(array+3)等于3。其它依此类推。  

例九：  
例九：  
char*str[3]={  
"Hello,thisisasample!",  
"Hi,goodmorning.",  
"Helloworld"  
};  
chars[80]；  
strcpy(s,str[0]);//也可写成strcpy(s,*str);  
strcpy(s,str[1]);//也可写成strcpy(s,*(str+1));  
strcpy(s,str[2]);//也可写成strcpy(s,*(str+2));  
上例中，str是一个三单元的数组，该数组的每个单元都是一个指针，这些指  
针各指向一个字符串。把指针数组名str当作一个指针的话，它指向数组的第0号  
单元，它的类型是char**，它指向的类型是char*。  
*str也是一个指针，它的类型是char*，它所指向的类型是char，它指向的地  
址是字符串"Hello,thisisasample!"的第一个字符的地址，即'H'的地址。  
str+1也是一个指针，它指向数组的第1号单元，它的类型是char**，它指向  
的类型是char*。  
*(str+1)也是一个指针，它的类型是char*，它所指向的类型是char，它指向  
"Hi,goodmorning."的第一个字符'H'，等等。  

下面总结一下数组的数组名的问题。声明了一个数组TYPEarray[n]，则数组  
名称array就有了两重含义：第一，它代表整个数组，它的类型是TYPE[n]；第二  
，它是一个指针，该指针的类型是TYPE*，该指针指向的类型是TYPE，也就是数组  
单元的类型，该指针指向的内存区就是数组第0号单元，该指针自己占有单独的内  
存区，注意它和数组第0号单元占据的内存区是不同的。该指针的值是不能修改的  
，即类似array++的表达式是错误的。  
在不同的表达式中数组名array可以扮演不同的角色。  
在表达式sizeof(array)中，数组名array代表数组本身，故这时sizeof函数  
测出的是整个数组的大小。  
在表达式*array中，array扮演的是指针，因此这个表达式的结果就是数组第  
0号单元的值。Sizeof(*array)测出的是数组单元的大小。  
表达式array+n（其中n=0，1，2，….。）中，array扮演的是指针，故arr  
ay+n的结果是一个指针，它的类型是TYPE*，它指向的类型是TYPE，它指向数组第  
n号单元。故sizeof(array+n)测出的是指针类型的大小。  
 
 
  
 作者： 61.128.167.*  2006-5-12 14:45 　 回复此发言    
 
--------------------------------------------------------------------------------
 
4 C指针学习(转)  
 例十：  
intarray[10];  
int(*ptr)[10];  
ptr=&array;  
上例中ptr是一个指针，它的类型是int(*)[10]，他指向的类型是int[10]  
，我们用整个数组的首地址来初始化它。在语句ptr=&array中，array代表数组本  
身。  

本节中提到了函数sizeof()，那么我来问一问，sizeof(指针名称)测出的究  
竟是指针自身类型的大小呢还是指针所指向的类型的大小？答案是前者。例如：  

int(*ptr)[10];  
则在32位程序中，有：  
sizeof(int(*)[10])==4  
sizeof(int[10])==40  
sizeof(ptr)==4  
实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么  
类型的大小。  
第六章。指针和结构类型的关系  


可以声明一个指向结构类型对象的指针。  
例十一：  
structMyStruct  
{  
inta;  
intb;  
intc;  
}  
MyStructss={20,30,40};//声明了结构对象ss，并把ss的三个成员初始  
化为20，30和40。  
MyStruct*ptr=&ss;//声明了一个指向结构对象ss的指针。它的类型是  
MyStruct*,它指向的类型是MyStruct。  
int*pstr=(int*)&ss;//声明了一个指向结构对象ss的指针。但是它的  
类型和它指向的类型和ptr是不同的。  

请问怎样通过指针ptr来访问ss的三个成员变量？  
答案：  
ptr->a;  
ptr->b;  
ptr->c;  
又请问怎样通过指针pstr来访问ss的三个成员变量？  
答案：  
*pstr；//访问了ss的成员a。  
*(pstr+1);//访问了ss的成员b。  
*(pstr+2)//访问了ss的成员c。  
呵呵，虽然我在我的MSVC++6.0上调式过上述代码，但是要知道，这样使用p  
str来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指  
针来访问数组的各个单元：  
例十二：  
intarray[3]={35,56,37};  
int*pa=array;  
通过指针pa访问数组array的三个单元的方法是：  
*pa;//访问了第0号单元  
*(pa+1);//访问了第1号单元  
*(pa+2);//访问了第2号单元  
从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。  
所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的  
存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种  
编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两  
个成员之间加若干个"填充字节"，这就导致各个成员之间可能会有若干个字节  
的空隙。  
所以，在例十二中，即使*pstr访问到了结构对象ss的第一个成员变量a，也  
不能保证*(pstr+1)就一定能访问到结构成员b。因为成员a和成员b之间可能会有  
若干填充字节，说不定*(pstr+1)就正好访问到了这些填充字节呢。这也证明了指  
针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，  
嘿，这倒是个不错的方法。  
通过指针访问结构成员的正确方法应该是象例十二中使用指针ptr的方法。  

第七章。指针和函数的关系  


可以把一个指针声明成为一个指向函数的指针。  
intfun1(char*,int);  
int(*pfun1)(char*,int);  
pfun1=fun1;  
….  
….  
inta=(*pfun1)("abcdefg",7);//通过函数指针调用函数。  
可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为  
实参。  
例十三：  
intfun(char*);  
inta;  
charstr[]="abcdefghijklmn";  
a=fun(str);  
…  
…  
intfun(char*s)  
{  
intnum=0;  
for(inti=0;i{  
num+=*s;s++;  
}  
returnnum;  
}  
这个例子中的函数fun统计一个字符串中各个字符的ASCII码值之和。前面说  
了，数组的名字也是一个指针。在函数调用中，当把str作为实参传递给形参s后  
，实际是把str的值传递给了s，s所指向的地址就和str所指向的地址一致，但是  
str和s各自占用各自的存储空间。在函数体内对s进行自加1运算，并不意味着同  
时对str进行了自加1运算。  

第八章。指针类型转换  
 
 
  
 作者： 61.128.167.*  2006-5-12 14:45 　 回复此发言    
 
--------------------------------------------------------------------------------
 
5 C指针学习(转)  
 

当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋  
值号的右边是一个指针表达式。在我们前面所举的例子中，绝大多数情况下，指  
针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向  
的类型是一样的。  
例十四：  
1。Floatf=12.3;  
2。Float*fptr=&f;  
3。Int*p;  
在上面的例子中，假如我们想让指针p指向实数f，应该怎么搞？是用下面的  
语句吗？  
p=&f;  
不对。因为指针p的类型是int*，它指向的类型是int。表达式&f的结果是一  
个指针，指针的类型是float*,它指向的类型是float。两者不一致，直接赋值的  
方法是不行的。至少在我的MSVC++6.0上，对指针的赋值语句要求赋值号两边的类  
型一致，所指向的类型也一致，其它的编译器上我没试过，大家可以试试。为了  
实现我们的目的，需要进行"强制类型转换"：  
p=(int*)&f;  
如果有一个指针p，我们需要把它的类型和所指向的类型改为TYEP*和TYPE，  
那么语法格式是：  
(TYPE*)p；  
这样强制类型转换的结果是一个新指针，该新指针的类型是TYPE*，它指向的  
类型是TYPE，它指向的地址就是原指针指向的地址。而原来的指针p的一切属性都  
没有被修改。  

一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结  
合过程中，也会发生指针类型的转换。  
例十五：  
voidfun(char*);  
inta=125,b;  
fun((char*)&a);  
…  
…  
voidfun(char*s)  
{  
charc;  
c=*(s+3);*(s+3)=*(s+0);*(s+0)=c;  
c=*(s+2);*(s+2)=*(s+1);*(s+1)=c;  
}  
}  
注意这是一个32位程序，故int类型占了四个字节，char类型占一个字节。函  
数fun的作用是把一个整数的四个字节的顺序来个颠倒。注意到了吗？在函数调用  
语句中，实参&a的结果是一个指针，它的类型是int*，它指向的类型是int。形  
参这个指针的类型是char*，它指向的类型是char。这样，在实参和形参的结合过  
程中，我们必须进行一次从int*类型到char*类型的转换。结合这个例子，我们可  
以这样来想象编译器进行转换的过程：编译器先构造一个临时指针char*temp，  
然后执行temp=(char*)&a，最后再把temp的值传递给s。所以最后的结果是：s的  
类型是char*,它指向的类型是char，它指向的地址就是a的首地址。  

我们已经知道，指针的值就是指针指向的地址，在32位程序中，指针的值其  
实是一个32位整数。那可不可以把一个整数当作指针的值直接赋给指针呢？就象  
下面的语句：  
unsignedinta;  
TYPE*ptr;//TYPE是int，char或结构类型等等类型。  
…  
voidfun(char*s)  
{  
charc;  
c=*(s+3);*(s+3)=*(s+0);*(s+0)=c;  
c=*(s+2);*(s+2)=*(s+1);*(s+1)=c;  
}  
}  
注意这是一个32位程序，故int类型占了四个字节，char类型占一个字节。函  
数fun的作用是把一个整数的四个字节的顺序来个颠倒。注意到了吗？在函数调用  
语句中，实参&a的结果是一个指针，它的类型是int*，它指向的类型是int。形  
参这个指针的类型是char*，它指向的类型是char。这样，在实参和形参的结合过  
程中，我们必须进行一次从int*类型到char*类型的转换。结合这个例子，我们可  
以这样来想象编译器进行转换的过程：编译器先构造一个临时指针char*temp，  
然后执行temp=(char*)&a，最后再把temp的值传递给s。所以最后的结果是：s的  
类型是char*,它指向的类型是char，它指向的地址就是a的首地址。  

我们已经知道，指针的值就是指针指向的地址，在32位程序中，指针的值其  
实是一个32位整数。那可不可以把一个整数当作指针的值直接赋给指针呢？就象  
下面的语句：  
unsignedinta;  
TYPE*ptr;//TYPE是int，char或结构类型等等类型。  
…  
…  
a=20345686;  
ptr=20345686;//我们的目的是要使指针ptr指向地址20345686（十进制  
 
 
  
 作者： 61.128.167.*  2006-5-12 14:45 　 回复此发言    
 
--------------------------------------------------------------------------------
 
6 C指针学习(转)  
 ）  
ptr=a;//我们的目的是要使指针ptr指向地址20345686（十进制）  
编译一下吧。结果发现后面两条语句全是错的。那么我们的目的就不能达到  
了吗？不，还有办法：  
unsignedinta;  
TYPE*ptr;//TYPE是int，char或结构类型等等类型。  
…  
…  
a=某个数，这个数必须代表一个合法的地址；  
ptr=(TYPE*)a；//呵呵，这就可以了。  
严格说来这里的(TYPE*)和指针类型转换中的(TYPE*)还不一样。这里的(TYP  
E*)的意思是把无符号整数a的值当作一个地址来看待。  
上面强调了a的值必须代表一个合法的地址，否则的话，在你使用ptr的时候  
，就会出现非法操作错误。  

想想能不能反过来，把指针指向的地址即指针的值当作一个整数取出来。完  
全可以。下面的例子演示了把一个指针的值当作一个整数取出来，然后再把这个  
整数当作一个地址赋给一个指针：  
例十六：  
inta=123,b;  
int*ptr=&a;  
char*str;  
b=(int)ptr;//把指针ptr的值当作一个整数取出来。  
str=(char*)b;//把这个整数的值当作一个地址赋给指针str。  

好了，现在我们已经知道了，可以把指针的值当作一个整数取出来，也可以  
把一个整数值当作地址赋给一个指针。  


第九章。指针的安全问题  


看下面的例子：  
例十七：  
chars='a';  
int*ptr;  
ptr=(int*)&s;  
*ptr=1298；  
指针ptr是一个int*类型的指针，它指向的类型是int。它指向的地址就是s的  
首地址。在32位程序中，s占一个字节，int类型占四个字节。最后一条语句不但  
改变了s所占的一个字节，还把和s相临的高地址方向的三个字节也改变了。这三  
个字节是干什么的？只有编译程序知道，而写程序的人是不太可能知道的。也许  
这三个字节里存储了非常重要的数据，也许这三个字节里正好是程序的一条代码  
，而由于你对指针的马虎应用，这三个字节的值被改变了！这会造成崩溃性的错  
误。  
让我们再来看一例：  
例十八：  
1。Chara;  
2。Int*ptr=&a;  
…  
…  
3。Ptr++;  
4。*ptr=115;  
该例子完全可以通过编译，并能执行。但是看到没有？第3句对指针ptr进行  
自加1运算后，ptr指向了和整形变量a相邻的高地址方向的一块存储区。这块存储  
区里是什么？我们不知道。有可能它是一个非常重要的数据，甚至可能是一条代  
码。而第4句竟然往这片存储区里写入一个数据！这是严重的错误。所以在使用指  
针时，程序员心里必须非常清楚：我的指针究竟指向了哪里。  
在用指针访问数组的时候，也要注意不要超出数组的低端和高端界限，否则  
也会造成类似的错误。  
在指针的强制类型转换：ptr1=(TYPE*)ptr2中，如果sizeof(ptr2的类型)大  
于sizeof(ptr1的类型)，那么在使用指针ptr1来访问ptr2所指向的存储区时是安  
全的。如果sizeof(ptr2的类型)小于sizeof(ptr1的类型)，那么在使用指针ptr1  

来访问ptr2所指向的存储区时是不安全的。至于为什么，读者结合例十七来想一  
想，应该会明白的。  



---------------------------------------------------------------------------------------------------------------------------- 



说C・指针                                        

1从变量说起 
变量是使用频率最高的语言构造。它在物理上为数据提供可靠的存储空间，在逻辑上为存储空间提供有效的地址别名。编译器完全屏蔽了这样的事实：操作一个变量的实质是操作它所代表的内存地址。可以说，使用变量能让程序员放心大胆地向前走，不必担心对错误的地址执行语法、语义都正确的操作。 
但仅仅使用变量是不够的，因为变量名所代表的内存地址是在编译期就已经确定下来的静态信息。在执行过程中，访问变量等同于访问某个已经确定的地址（静态意义在于此）。有如下代码： 
int a = 0;              // 1，全局变量 

void foo() 
{ 
 
 
  
 作者： 61.128.167.*  2006-5-12 14:45 　 回复此发言    
 
--------------------------------------------------------------------------------
 
7 C指针学习(转)  
     int b = a + 1;     // 2，局部变量 
    …                   
} 
对于全局变量a，编译器在机器码中放置的是它的直接地址：在1处，可能的机器码是 
mov [xxxxxxxx],  0 
其中xxxxxxxx是a代表的直接地址。在不同的作用域内，如果没有同名的变量将a覆盖，则对a的访问都是对地址xxxxxxxx的访问，比如2处的取a值并与1相加的操作。在执行期内我们无法改变“在无同名变量覆盖的情况下，访问a即是访问地址xxxxxxxx”这样的语义，因此在这里a代表的内存地址是一种静态信息。 
而对于局部变量b，可能会有人争辩说“b不是分配在栈上的么，函数调用点不同b代表的内存地址也不同”。话是没错，但不妨换个角度思考一下b的语义：b代表的是一个“相对”地址，即相对于某个基地址进行偏移后的位置。这个偏移位置的量值在编译期已经确定好了，执行期是无法改变“b代表对基地址偏移yyyy后得到的地址”这样的语义（即无法在执行期改变偏移量yyyy的值）。因此，b代表的内存地址仍然是一种静态信息。相关的机器码可以用反汇编手段得到，此处不再列出。 
编译器使用上述的静态地址信息来确定如何正确地访问数据。这种机制对于编译期内就能确定的变量地址来说非常有用，但对于执行期才能确定的变量地址就无能为力DD因为你可能不知道这地址是什么DD它可以是别的程序、别的程序员、甚至是运行时库或操作系统在执行期要求你使用的任何变量地址，而在编译期内这些地址值是无法确定的（从逻辑上说，是因为程序员和编译器都“看”不到这些地址的别名，即变量名）。如果没有合适的机制来提供访问执行期才能确定的变量地址，我们编写的函数（比如某种处理字符串或者整型值的算法的C实现版本）就无法通用化了，只能由自己的程序调用。这并不是我们想达到的目的，特别是在编写函数库的时候。 
有没有好的办法来解决这种问题呢？ 
2哪儿跌倒，哪儿爬起来 
还是让我们研究一下微机原理，来看看操作变量时到底发生了什么。 
总线控制器通过地址线来确定CPU想要访问哪个地址上的数据。也就是说，CPU首先要在地址线上写入适当的地址信息才能通知总线控制器去取出它想要的数据。从这个角度来看，地址信息本身也可以视为一种特殊的数据。这种特殊数据一般不由程序员直接控制，而全由编译器来设定。其机器码形式有如 
mov [xxxxxxxx],  0 
所示，编译器解决了其中的xxxxxxxx，从而释放了程序员的手。当CPU看见这条机器码的时候，它就取出保存在码中地址信息，然后把它放到地址线上等待处理。看到这里，聪明的你应该可以联想到什么了吧？ 
对，那就是，如果用一个寄存器来代替xxxxxxxx，就可以实现出动态地址了么。实际上，CPU的指令集也允许我们这么做。通过写下 
mov [ebx],  0 
这样的代码，我们能够把地址信息的决定时间推迟到执行期：等到执行该代码的时候CPU才取出寄存器ebx中的数据，作为地址信息写到地址线上。如果别的程序、运行时库或者操作系统在CPU执行这句代码前，在ebx中放置了适当的地址值，那就可以在使得程序能访问到正确的数据了。Bingo！ 
呃，别高兴太早……这种是机器码，不是C代码。如果要在C中实现出上述的动态地址信息且能被程序员掌握使用，那还得在语法和语义上加把劲儿。 
 
 
  
 作者： 61.128.167.*  2006-5-12 14:45 　 回复此发言    
 
--------------------------------------------------------------------------------
 
8 回复：C指针学习(转)  
 蛮详细的。。！~  
 
  
 作者： 不再流I的N子  2006-5-12 14:52 　 回复此发言    
 
--------------------------------------------------------------------------------
 
9 回复：C指针学习(转)  
 程序中的指针的运用非常重要，但也需运用的巧妙，顶一下。  
 
  
 作者： love黄晓   2006-5-12 15:37 　 回复此发言    
 
--------------------------------------------------------------------------------
 
